# 15장 고급주제와 성능 최적화

## 15.4 성능 최적화 
### 15.4.1 N+1 문제 
- JPA로 애플리케이션을 개발 할 때 성능상 가장 주의해야 하는 것은  N+1 문제다. 
```java
@Entity 
public class Member {
    ...

    @OneToMany(mappedBy = "member", fetch=FetchType.EAGER)
    private List<Order> orders = new ArrayList<Order>();
    ...
}

@Entity 
public class Order {
    ...
    @ManyToOne
    private Member member;
    ...
}

```
#### 즉시로딩과 N+1 
- 특정 회원 하나를 em.find() 메소드로 조회하면 즉시로딩으로 설정한 주문 정보도 함께 조회한다. 
- 조회 방법은 SQL을 두번 실행하는 것이 아니라 조인을 사용해서 한번의 SQL로 조회한다. 
- JPQL로 실행을 할경우 JPA는 이것을 분석해서 SQL을 생성할 때 처음 실행한 SQL의 결과 수만큼 추가로 SQL을 실행하는 것을 N+1 문제라고 한다. 


#### 지연로딩과 N+1 
- 
#### 페치조인 사용 
- N+1 문제를 해결하는 가장 일반적인 방법은 페치조인을 사용하는 것이다. 
- 페치 조인은 SQL 조인을 사용해서 연관된 엔티티를 함께 조회하는 것이므로 N+1 문제가 발생하지 않는다.

#### 하이버네이트 @BatchSize 
- 하이버네이트가 제공하는 org.hibernate.annotations.BatchSize 어노테이션을 사용하면 연관 엔티티를 조회할 때 지정한 size만큼 SQL의 IN절을 사용해서 조회한다. 


#### 하이버네이트 @Fetch(FetchMode.SUBSELECT)
- 하이버네이트가 제공하는 org.hibernate.annotations.Fetch 어노테이션에 FetchMode를 SUBSELECT로 사용하면 연관된 데이터를 조회할 때 서브쿼리를 사용해서 N+1문제를 해결한다. 


#### N+1 정리 
- 즉시로딩과 지연로딩 중 지연 로딩만 사용하는 것을 권장한다. 즉시 로딩은 성능 최적화가 어렵다. 모두 지연로딩으로 설정하고 성능 최적화가 필요한 곳에는 JPQL페치 조인을 사용하도록 한다. 
- @OneToOne, @ManyToOne : 기본 페치 전략은 즉시 로딩 
- @OneToMany, @ManyToMany : 기본 페치 전략은 지연 로딩 


### 15.4.2 읽기 전용 쿼리의 성능 최적화 
- 엔티티가 영속성 컨텍스트에 관리되면 1차 캐시 부터 변경 감지 까지 얻을 수 있는 이점이 많다. 
- 영속성 컨텍스트는 변경감지를 위해 스냅샵 인스턴스를 보관하므로 더 많은 메모리를 사용한다는 단점이 있다. 
- 단순 조회의 경우 조회한 엔티티를 다시 조회할 일도 없고 수정할 일도 없을 때는 읽기 전용으로 엔티티를 조회하면 메모리 사용량을 최적화 가능하다. 

#### 스칼라 타입 조회 
- 엔티티가 아닌 스칼라 타입으로 조회하면 영속성 컨텍스트가 결과를 관리하지 않는다. 

#### 읽기 전용 쿼리 힌트 사용 
- 하이버네이트 전용 힌트인 org.hibernate.readOnly를 사용하면 엔티티를 읽기 전용으로 조회가능 하며 영속성 컨텍스트에 스냅샵을 보관하지 않는다. 
#### 읽기 전용 트랜잭션 사용 
- 스프링 프레임워크를 사용하면 트랜잭션을 읽기 전용 모드로 설정 가능하다. 
- @Transactional(readOnly = true) 
#### 트랜잭션 밖에서 읽기 
- 트랜잭션 없이 엔티티를 조회한다는 의미이다. 
- @Transactional(propagation = Propagation.NOT_SUPPORTED)
- @TransactionaAttribute(TransactionAttribute.NOT_SUPPORTED)
- 트랜잭션을 사용하지 않으면 플러시가 일어나지 않으므로 조회 성능이 향상된다. 

#### 읽기 전용 쿼리 정리 
- 읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트를 동시에 사용하는 것이 가장 효과적이다. 
```java
@Transactional(readOnly = true) // 읽기 전용 트랜잭션 
public List<Entity> findData(){
    return em.createQuery("select d from Entity d",
            Entity.class)
            .setHint("org.hibernate.readOnly", true)// 읽기 전용 쿼리 힌트 
            .getResultList();
}

```

### 15.4.3 배치처리
#### JPA등록 배치 
- 수천~수만 건 이상의 데이터를 한 번에 등록할 때 주의할 점은 영속성 컨텍스트에 엔티티가 계속 쌓이지 않도록 일정 단위 마다 영속성 컨텍스트의 엔티티를 데이터베이스에 플러시하고 영속성 컨텍스트를 초기화 해야 한다. 

#### JPA 페이징 배치 처리 
- 배치 처리는 아무 많은 데이터를 조회해서 수정한다. 이 때 수많은 데이터를 한번에 메모리에 올려둘 수 없기 때문에 페이징 처리와 커서 기능을 사용한다. 
- JPA는 JDBC 커서 기능을 지원하지 않기 때문에 커서를 사용할려면 하이버네이트 Session을 사용해야 한다. 

#### 하이버네이트 Scroll 사용 
- 하이버네이트는 scroll이라는 이름으로 JDBC 커서를 지원한다. 

#### 하이버네이트 무상태 세션 사용 
- 하이버네이트는 무상태 세션이라는 특별한 기능을 제공한다. 무상태 세션은 영속성 컨텍스트를 만들지 않고 2차 캐시도 사용하지 않는다. 
- 엔티티를 수정하려면 무상태 세션이 제공하는 update()메소드를 직접 호출해야 한다. 

#### 15.4.4 SQL 쿼리 힌트 사용 
- JPA는 데이터베이스 힌트 기능을 제공하지 않는다. SQL 힌트를 사용하려면 하이버네이트에서 직접 사용해야 한다. 
- SQL 힌트는 하이버네이트 쿼리가 제공하는 addQueryHint() 메소드를 사용한다. 

#### 15.4.5 트랜잭션을 지원하는 쓰기 지연과 성능 최적화 
- 네트워크 호출 한번은 단순한 메소드를 수만 번 호출 하는 것 보다 더 큰 비용이 발생한다. 
- JDBC가 제공하는 SQL배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한번에 보내줄 수 있다. 이 기능을 사용하기 위해서는 코드의 많은 부분을 수정해야 하고 코드가 상당히 지저분해진다. 
- SQL 배치 최적화 전략은 구현체 마다 조금씩 다르지만 하이버네이트에서 SQL 배치를 적용하려면 아래와같이 설정한다. 
```xml
<property name="hibernate.jdbc.batch_size" value="50">
``` 

#### 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 성능 확장 
- 트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능 덕분에 성능, 개발 편의성이라는 장점이 있지만 가장 큰 장점은 데이터베이스 로우에 락이 걸리는 시간을 최소화한다. 
- 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제 하지 않기 때문에 커밋 직전 까지 데이터 베이스 로우에 락을 걸지 않는다. 
- 쿼리를 보내고 바로 트랜잭션을 커밋하므로 데이터베이스 락이 걸리는 시간을 최소한 한다. 


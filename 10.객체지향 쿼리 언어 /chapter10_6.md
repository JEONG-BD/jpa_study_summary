# 10장 객제지향 쿼리 언어 
## 10.6 객체지향 쿼리 심화 
### 10.6.1 벌크 연산 
- 엔티티를 수정하려면 영속성 컨텍스트의 변경 감지 기능이나 병합을 사용하고 삭제 하려면 EntityMaanger.remove()메소드를 사용한다. 
```java
String qlString = 
	"update Product p " +
	"set p.price = p.price * 1.1 " +
	"where p.stockAmount < :stockAmount";

int resultCount = em.createQuery(qlString)
				.setParameter("stockAmount", 10)
				.executeUpdate();
```
- 벌크연산은 executeUpdate() 메소드를 사용한다. 
```java
String qlString = 
	"delete from Product p " +
	"where p.price < :price";

int resultCount = em.createQuery(qlString)
				.setParamter("price", 100)
				.executeUpdate();
```

#### 벌크연산 주의점 
- 벌크 연산을 사용할 때는 벌크 연산이 영속성 컨텍스트를 무시하고 데이터베이스에 직접 쿼리한다는 점에 주의 해야 한다. 
- 벌크 연산은 영속성 컨텍스트를 통하지 않고 데이터 베이스에 직접 쿼리한다. 영속성 컨텍스트에 있는 객체와 데이터베이스에 있는 Row의 값이 다를 수 있다. 

#### em.refresh() 사용 
- 벌크 연산을 수행한 직후 다시 엔티티를 사용해야 한다면 em.refresh()를 사용해서 데이터베이스에서 엔티티를 다시 조회하면 된다. 
#### 벌크 연산 먼저 실행 
- 벌크 연산을 가장 먼저 실행한다.
 
#### 벌크 연산 수행 후 영속성 컨텍스트 초기화 
- 벌크 연산 수행 후 영속성 컨텍스트를 초기화 해서 영속성 컨텍스트에 남아 있는 엔티티를 제거하는 것도 좋은 방법이다. 

### 10.6.2 영속성 컨텍스트와 JPQL 
#### 쿼리 후 영속 상태인 것과 아닌 것 
- JPQL로 엔티티를 조회하면 영속성 컨텍스트에 관리 되지만 엔티티가 아닌면 영속성 컨텍스트에서 관리되지 않는다. 

#### JPQL로 조회한 엔티티와 영속성 컨텍스트 
- JPQL로 데이터베이스에 조회한 엔티티가 영속성 컨텍스트에 이미 있으면 JPQL로 데이터베이스에서 조회한 결과를 버리고 대신에 영속성 컨텍스트에 있던 엔티티를 반환한다. 
- 영속성 컨텍스트는 영속 상태인 엔티티의 동일성을 보장한다. em.find()로 조회하든 JPQL을 사용하든 영속성 컨텍스트가 같으면 동일한 엔티티를 반환한다. 

#### find()	vs JPQL 
- em.find() 메소드는 엔티티를 영속성 컨텍스트에서 먼저 찾고 없으면 데이터베이스에서 찾는다. 
- 해당 엔티티가 영속성 컨텍스트에 있으면 메모리에서 바로 찾으므로 성능상 이점이 있다. 
- JPQL은 항상 데이터베이스에 SQL을 실행해서 결과를 조회한다.
- em.find() 메소드는 영속성 컨텍스트에서 엔티티를 먼저 찾고 없으면 데이터베이스를 조회하지만 JPQL을 사용하면 데이터베이스를 먼저 조회한다. 


### 10.6.3 JPQL과 플러시 모드
- 플러시는 영속성 컨텍스트의 변경 내역을 데이터베이스에 동기화하는 것이다. 
- JPA는 플러시가 일어날 때 영속성 컨텍스트에 등록, 수정, 삭제한 엔티티를 찾아서 INSERT, UPDATE, DELETE SQL을 만들어서 데이터베이스에 반영한다. 

#### 쿼리와 플러시모드 
- JPQL은 영속성 컨텍스트에 있는 데이터를 고려하지 않고 데이터베이스에서 데이터를 조회한다. 
- JPQL을 실행하기 전에 영속성 컨텍스트의 내용을 데이터베이스에 반영해야하며 그렇지 않으면 의도 하지 않은 결과가 발생한다. 

#### 플러시 모드와 최적화 
- FlushModeType.COMMIT모드는 커밋할 때만 플러시하고 쿼리를 실행할 때는 플러시하지 않는다. JPA쿼리를 사용할 때는 영속성 컨텍스트에 있지만 아직 데이터 베이스에 반영하지 않은 데이터를 조회할 수 없다. 
- 플러시가 너무 자주 일어나는 상황에서 이 모드를 사용하면 쿼리시 발생하는 플러시 횟수를 줄여서 성능 최적화가 가능하다. 
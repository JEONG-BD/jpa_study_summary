# 16장 트랜잭션과 락, 2차캐시 
## 16.1 트랜잭션과 락 
### 16.1.1 트랜잭션과 격리 수준 
- 트랜잭션은 원자성, 일관성, 격리성, 지속성을 보장해야 한다. 
1. 원자성 : 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것 처럼 모두 성공 또는 모두 실패 해야한다. 
2. 일관성 : 일관성 있는 데이터베이스 상태를 유지해야한다. 
3. 격리성 : 동시에 실행되는 트랜잭션들이 서로에게 영향을 미치치 않도록 격리해야 한다. 
4. 지속성 : 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 

- 트랜잭션의 격리 수준은 아래와 같다. 
1. READ UNCOMMITED
2. READ COMMITTED
3. REPEATABLE READ 
4. SERIZLIZABLE 
- 트랙잭션의 격리 수준의 문제점 

|격리수준|DIRTY READ|NON-REPEATABLE READ|PHANTOM READ|
|--|--|--|---|
|READ UNCOMMITED|O|O|O|
|READ COMMITTED||O|O|
|REPEATABLE READ|||O|
|SERIZLIZABLE||||

- READ UNCOMMITTED 
    - 커밋하지 않은 데이터를 읽을 수 있다. 트랜잭션 1이 수정 작업을 하고 있고 트랜잭션 2가 데이터를 조회할 수 있는 것을 DIRTY READ라 한다. 
    - 트랜잭션 1이 롤백을 하면 데이터 정합성에 큰 문제가 발생할 수 있다. 
    - DIRTY READ를 허용하는 격리 수준을 READ UNCOMMITTED라 한다. 
- READ COMMITTED 
    - 커밋한 데이터만 읽을 수 있다. 따라서 DIRTY READ가 발생하지 않는다. 
    - 트랜잭션 1이 회원 A를 조회 중인데 트랜잭션 2가 회원 A를 수정 하고 커밋하면 트랜잭션 1이 다시 조회하면 수정된 데이터가 조회된다. 
    - 반복해서 같은 데이터를 읽을 수 없는 상태를 NON-REPEATABLE READ 라고 한다. 
- REPEATABLE READ
    - 한 번 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 
    - 트랜잭션 1이 10살 이하의 회원 조회했는데 트랜잭션 2가 5살 회원을 추가하고 커밋하면 트랜잭션 1이 다시 10살 이하의 회원을 조회했을 때 하나가 추가된 상태로 조회된다. 
    - 반복 조회시 결합 집합이 달라지는 것을 PHANTOM READ라 한다. 

- SERIALIZABLE 
    - 가장 엄격한 트랜잭션 격리 수준이다. 동시성 처리 성능이 급격히 떨어진다. 

- 애플리케이션은 대부분 동시성 처리가 중요하므로 데이터베이스들은 보통 READ COMMITTED 격리 수준을 기본으로 사용한다. 
- 일부 중요한 비즈니스 로직에 더 높은 격리 수준이 필요하면 데이터베이스의 트랜잭션이 제공하는 잠금 기능을 사용하면 된다. 

### 16.1.2 낙관적 락과 비관적 락 기초 
- JPA의 영속성 컨텍스트를 적절히 활용하면 데이터베이스 트랜잭션이 READ COMMITTED격리 수준이라고 해도 애플리케이션에서 반복 읽기가 가능하다. 
- JPA는 데이터베이스 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정한다. 
- 일부 로직에서 더 높은 격리 수준이 필요하면 낙관적 락과 비관적 락 중 하나를 사용하면 된다. 

#### 낙관적 락(Optimistic Lock)
- 트랜잭션 대부분 충돌이 발생하지 않는다고 낙관적으로 가정하는 방법 
- 데이터베이스의 락 기능을 사용하는 것이 아니라 JPA가 제공하는 버전 관리 기능을 사용한다. 
- 낙관적 락은 트랜잭션을 커밋하기 전까지 충돌을 알 수 없다. 

#### 비관적 락(Pessimistic Lock)
- 트랜잭션 충돌이 발생한다고 가정하고 우선 락을 걸고 보는 방법이다. 
- 데이터베이스가 제공하는 락 기능을 사용한다. 

#### 두번의 갱신 분실 문제(Second lost updates problem)
- 사용자 A와 B동시에 제목이 같은 공지사항을 수정한다. 
- 사용자 A가 먼저 수정 완료 버튼을 누른후 잠시 후 사용자 B가 수정완료 버튼을 누른다. 
- 사용자 A의 수정사항은 사라지고 나중에 완료한 사용자 B의 수정사항만 남게 된다. 
- 두 번의 갱신 분실 문제는 데이터베이스 트랜잭션의 범위를 넘어서는데 이때는 3가지 선택 방법이 있다. 
- 마지막 커밋만 인정하기(기본) 
- 최초 커밋만 인정하기 
- 충돌하는 갱신 내용 병합하기 

### 16.1.3 @Version 
- JPA가 제공하는 낙관적 락을 사용하려면 @Version 어노테이션을 사용해서 버전 관리 기능을 추가해야 한다. 
```java
@Entity
public class Board{
    @Id 
    private String id; 
    private String title; 

    @Version 
    private Integer version; 
    /**
     * Long 
     * Integer
     * Short 
     * Timestamp 
     **/
      
}
```
- 버전 관리 기능을 적용하려면 엔티티에 버전 관리용 필드를 하나 추가하고 @Version을 붙이면 된다. 
- 엔티티를 수정할 때 마다 버전이 하나씩 자동으로 증가한다. 엔티티를 수정할 때 조회 시점의 버전과 수정 시점의 버전이 다르면 예외가 발생한다. 

#### 버전 정보 비교 방법 
- 엔티티를 수정후 트랜잭션을 커밋하면 영속성 컨텍스트를 플러시 하면서 UPDATE 쿼리를 실행하는데 이때 버전을 사용하는 엔티티면 검색 조건에 버전 정보를 추가한다. 
- 데이터베이스 버전과 엔티티 버전이 같으면 데이터를 수정하면서 동시에 버전도 하나 증가 시킨다. 
- 값 타입(임베디트 아이브 값 타입 컬렉션)은 논리적인 개념상 해당 엔티티의 값이므로 수정하면 엔티티의 버전이 증가하지만 연관 관계 필드는 외래 키를 관리하는 연관관계의 주인 필드를 수정할 때만 증가한다. 

### 16.1.4 JPA락 사용 
- 락은 다음 위치에 적용이 가능하다. 
    - EntityManager.lock(), EntityManager.find(), EntityManager.refresh() 
    - Query.setLockMode() 
    - @NamedQuery 
```java 
Board board = em.find(Board.class, id, LockModeType.OPTIMISTIC)
Board board = em.find(Board.class, id)
em.lock(board, LockModeType.OPTIMISTIC)
```
- JPA가 제공하는 락 옵션은 javax.persistence.LockModeType에 정의되어 있다. 

### 16.1.5 JPA 낙관적 락 
- JPA가 제공하는 낙관적 락은 @Version을 사용하기 때문에 버전이 있어야 한다. 
- 낙관적 락은 커밋하는 시점에 충돌을 알 수 있다. 
- 락 옵션 없이 @Version 만 있어도 락이 적용된다. 락 옵션을 사용하면 락을 더 세밀하게 설정이 가능하다. 

#### None 
- 락 옵션을 적용하지 않아도 엔티티에 @Version이 적용된 필드만 있으면 낙관적 락이 적용된다. 
- 용도 : 조회한 엔티티를 수정할 때 다른 트랜잭션에 의해 변경이 되지 않아야 한다. 
- 동작 : 엔티티를 수정할 때 버전을 체크하면서 버전을 증가한다. 이때 데이터베이스의 버전 값이 현재 버전이 아니면 예외가 발생한다. 
- 이점 : 두 번의 갱신 분실 문제를 예방한다. 

#### OPTIMISTIC 
- @Version만 적용했을 때는 엔티티를 수정해야 버전을 체크할 수 있지만 이 옵션을 추가하면 엔티티를 조회한 해도 버전을 체크한다. 
- 용도 : 조회한 엔티티는 트랜잭션이 끝날 때까지 다른 트랜잭션에 의해 변경되지 않아야 한다. 조회 시점 부터 트랜잭션ㅇ 끝날 때까지 조회한 엔티티가 변경되지 않음을 보장한다. 
- 동작 : 트랜잭션을 커밋할 때 버전 정보를 조회해서 현재 엔티티의 버전과 같은 지검증 한다. 
- 이점 : OPTIMISTIC 옵션은 DIRTY READ와 NONE-REPETABLE READ를 방지한다. 

#### OPTIMISTIC_FORCE_INCREMENT 
- 낙관적 락을 사용하면서 버전 정보를 강제로 증가한다. 
- 용도 : 논리적인 단위의 엔티티 묶음을 관리할 수 있다.
- 동작 : 엔티티를 수정하지 않아도 트랜잭션을 커밋할 때 UPDATE 쿼리를 사용해서 버전 정보를 강제로 증가 시킨다. 이때 데이터베이스의 버전이 엔티티의 버전과 다르면 예외를 발생시킨다. 
- 이점 : 강제로 버전을 증가해서 논리적인 단위의 엔티티 묶음을 버전 관리할 수 있다. 

### 16.1.6 JPA 비관적 락 
- JPA가 제공하는 비관적 락은 데이터베이스 트랜잭션 락 메커니즘에 의존하는 방법이다. 
- 주로 SQL 쿼리에 select for update 구문을 사용하면서 시작하고 버전 정보를 사용하지 않는다. 
- 비관적 락은 주로 PESSIMISTIC_WRITE 모드를 사용한다. 

#### 비관적 락의 특징 
- 엔티티가 아닌 스칼라 타입을 조회할 때도 사용가능하다. 
- 데이터를 수정하는 즉시 트랜잭션 충돌을 감지할 수 있다. 

#### PESSIMISTIC_WRITE 
- 비관적 락이라 함은 보통 이 옵션을 뜻한다. 데이터베이스에 락을 걸 때 사용한다. 
- 용도 : 데이터 베이스에 쓰기 락을 건다. 
- 동작 : 데이터베이스 select for update를 사용해서 락을 건다. 
- 이점 : NON-REPEATABLE READ를 방지한다. 락이 걸린 로우는 다른 트랜잭션에서 수정이 불가능하다. 

#### PESSIMISTIC_READ 
- 데이터 반복 읽기만 하고 수정하지 않는 용도로 락을 걸 때 사용한다. 일반적으로 사용하지 않는다. 
- 데이터베이스 대부분은 방언에 의해 PESSIMISTIC_READ로 동작한다. 

#### PESSIMISTIC_FORCE_INCREMENT
- 비관적 락 중 유일하게 버전 정보를 사용한다. 비관적 락이지만 버전 정보를 강제로 증가 시킨다. 
- 하이버네니트는 nowait를 지원하는 데이터베이스에 대해서 for update nowait 옵션을 적용한다. 


### 16.1.7 비관적 락과 타임아웃 
- 비관적 락을 사용하면 락을 획득할 때 까지 트랜잭션이 대기하며, 타음아웃을 줄 수도 있다. 


## 16.2 2차 캐시





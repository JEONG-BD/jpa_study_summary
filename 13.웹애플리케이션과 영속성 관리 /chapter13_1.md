# 13장 웹 애플리케이션과 영속성 관리 
## 13.1 트랜잭션 범위의 영속성 컨텍스트 
### 13.1.1 스프링 컨테이너의 기본 전략 
- 스프링 컨테이너는 트랜잭션 범위의 영속성 컨텍스트 전략을 기본으로 사용한다. 
- 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다. 같은 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다. 

- 서비스 계층에서 @Transactional 어노테이션을 선언해서 트랜잭션을 시작한다. 이 어노테이션이 있으면 호출한 메소드를 실행하기 직전에 스프링 트랜잭션의 AOP가 먼저 동작한다. 
- **트랜잭션이 같은 경우 같은 영속성 컨텍스트를 사용한다**. 트랜잭션 범위의 영속성 컨텍스트 전략은 다양한 위치에서 엔티티를 주입 받아서 사용해도 트랜잭션이 같으면 항상 같은 영속성 컨텍스트를 사용한다. 

- **트랜잭션이 다른 경우 다른 영속성 컨텍스트를 사용한다**. 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트트가 다르다.  

### 13.2 준영속 상태와 지연로딩 
- 트랜잭션은 보통 서비스 계층에서 시작하므로 서비스 계층이 끝나는 시점에 트랜잭션이 종료되면서 영속성 컨텍스트도 함께 종료한다.
- 조회한 엔티티는 서비스와 리포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만 컨트롤러와 뷰와 같은 프리젠테이션 계층에서는 준영속 상태가 된다. 

#### 준영속 상태와 변경 감지
- 변경 감지 기능은 영속성 컨텍스트가 살아있는 서비스 계층에서만 동작하고 프리젠테이션 계층에서는 동작하지 않는다. 유지 보수의 관점과 각 계층이 가지는 책임의 관점에서 비즈니스 로직은 서비스 계층에서 끝내고 프리젠테이션 계층은 데이터를 보여주는데 집중해야 한다. 

#### 준영속 상태와 지연 로딩 
- 준영속 상태의 가장 큰 문제는 지연 로딩이 동작하지 않는다는 점이다. 
- 준영속 상태의 지연 로딩을 해결하는 방법은 뷰가 필요한 엔티티를 미리 로딩하거나 OSIV를 사용해서 엔티티를 항상 영속 상태로 유지하는 방법이 있다. 

### 13.2.1 글로벌 페치 전략 수정 
- 글로버 페치 전략을 지연 로딩에서 즉시 로딩으로 변경하면 된다. 
#### 글로벌 페치 전략에 즉시 로딩 사용시 단점 
- 사용하지 않는 엔티티를 로딩하는 것과 N + 1 문제가 발생한다. 
- N+1 이 발생하면 SQL이 상당히 많이 호출되므로 성능에 치명적이지만 N+1 문제는 JPQL페치 조인으로 해결할 수 있다. 

```java
Order order =em.find(Order.class, 1L); 

//SQL 
select o.*, m.*
  from Order o 
  left outer join Member m on o.MEMBER_ID = m.MEMBER_ID 
  where o.id = 1 

select * from Order 
select * from Member where id = ? 
select * from Member where id = ? 
select * from Member where id = ? 
select * from Member where id = ? 

```
### 13.2.2 JPQL 페치 조인 
- 페치 조인은 JPQL을 호출하는 시점에 함께 로딩할 엔티티를 선택할 수 있다.
```java
JPQL
select o 
  from Order o 
  join fetch o.member


//SQL 
select o.*, m.*
  from Order o 
  join Member m on o.MEMBER_ID = m.MEMBER_ID
```
#### JPQL 페치조인의 단점 
- 페치 조인이 현실적인 대안이지만 무분별하게 사용하면 화면에 맞춘 리포지터리 메소드가 증가할 수 있다. 무분별한 최적화로 프리젠테이션 계층과 데이터 접근 계층 간에 의존관계가 증가하는 것 보다는 적절한 타협점을 찾는 것이 합리적이다. 

### 13.2.3 강제 초기화 
- 강제 초기화는 영속성 컨텍스트가 살아있을 때 프리젠테이션 계층에서 필요한 엔티티를 강제로 초기화 해서 변환하는 방법이다. 
- 하이버네이트를 사용하면 inirialize() 메소드를 사용해서 프로록시를 강제로 초기화할 수 있다. 
- 프록시를 초기화 하는 역할을 서비스 계층이 담당하면 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다. 서비스 계층은 비즈니스 로직을 담당해야지 프리젠테이션의 계층을 위한 일까지 담당하는것은 좋지 않다. 
- 비즈니스 로직을 담당하는 서비스 계층에서 프리젠테이션 계층을 위한 프록시 초기화 역할은 FACADE 계층이 담당해야 한다.  


### 13.2.4 FACADE 계층 추가 
- 뷰를 위한 프록시 초기화는 FACADE계층에서 담당하게 되면 서비스 계층에서 프록시를 초기화 하지 않아도 되고 서비스 계층과 프리젠테이션 계층의 논리적인 의존성을 분리할 수 있다. 
- 프록시를 초기화하려면 영속성 컨텍스트가 필요하므로 FACADE에서 트랜잭션을 시작해야 한다. 

#### FACADE계층의 역할과 특징 
- 프리젠테이션 계층과 도메인 모델 계층간의 논리적 의존성을 분리한다. 
- 프리젠테이션 계층에서 필요한 프록시 객체를 초기화한다. 
- 서비스 계층을 호출해서 비즈니스 로직을 실행한다. 
- 리포지터리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다. 


## 13.3 OSIV 
- OSIV는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다. 영속성 컨텍스트가 살아 있으면 엔티티는 영속 상태로 유지 되고 뷰까지 지연 로딩이 가능하다. 

### 13.3.1 과거 OSIV: 요청 당 트랜잭션 
- OSIV의 핵심은 뷰에서도 지연 로딩이 가능하도록 하는 것이다. 가장 단순한 구현 방법은 클라이언트 요청이 들어오자 마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 때 트랜잭션도 끝내는 것이다. 

#### 요청 당 트랜잭션 방식의 OSIV 문제점 
- OSIV가 가지는 문제점은 컨트롤러, 뷰 같은 프리젠테이션 계층이 엔티티를 변경할 수 있다는 점이다.

- 엔티티를 읽기 전용 인터페이스로 제공 
- 앤티티 래핑 
- DTO 반환

### 13.3.2 스프링 OSIV: 비즈니스 계층 트랜잭션 
#### 스프링 OSIV 분석
- 클라이언트의 요청이 들어오면 서블릿 필터나,스프링 인터셉터에서 영속성 컨텍스트를 생성한다. 단, 이때 트랜잭션은 시작하지 않는다.
- 서비스 계층에서 @Transactional로 트랜잭션을 시작할 때, 1번에서 미리 생성해 둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.
- 서비스 계층이 끝나면 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이때 트랜잭션은 끝내지만 영속성 컨텍스트는 종료하지 않는다.
- 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.
- 서블릿 필터나, 스프링 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 이때 플러시를 호출하지 않고 바로 종료한다.

#### 트랜잭션 없이 읽기
- 영속성 컨텍스트를 통한 모든 변경은 트랜잭션 안에서 이루어져야 한다. 
- 엔티티를 변경하지 않고 단순히 조회만 할 때는 트랜잭션이 없어도 되는데 이것을 트랜잭션 없이 읽기라 한다. 따라서 지연로딩이 가능하다.
- 스프링이 제공하는 OSIV를 사용하면 프리젠테이션 계층에서는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.

#### 스프링 OSIV 주의사항
- 프리젠테이션 계층에서 엔티티를 수정하고 트랜잭션을 시작하는 서비스 계층을 호출하면 수정이 데이터베이스 반영되는데 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있기 때문이다.
OSIV를 사용하지 않을 경우 트랜잭션 범위와 영속성 컨텍스트의 생명 주기가 같으므로 이런 문제가 발생하지 않는다. 

### 13.3.3 OSIV 정리
#### 스프링 OSIV의 특징 
- OSIV는 클라이언트 요청이 들어올 때 영속성 컨텍스트를 생성해서 요청이 끝날 때까지 영속성 컨텍스트를 유지한다. 
- 엔티티 수정은 트랜잭션이 있는 계층에서만 동작하지만 트랜잭션이 없는 프리젠테이션 계층은 지연 로딩을 포함해서 조회만 할 수 있다. 

#### 스프링 OSIV의 단점 
- OSIV를 적용하면 같은 영속성 컨텍스트를 여러 트랜잭션이 공유할 수 있다는 점에서 주의한다. 
- 프리젠테이션 계층에서 엔티티 수정 후 비즈니스 로직을 수행하면 엔티티가 수정될 수 있다. 
- 프리젠테이션 계층에서 지연로딩에 의한 SQL이 실행된다. 성능 튜닝시에 확인해야 할 부분이 넗다. 
